#!/usr/bin/python

import subprocess
import os
import hashlib
import yaml
import sys
import argparse
import string
import random

# Some web constants that are unlikely to change
ROS_SOURCES_LOCATION = "/etc/apt/sources.list.d/ros-latest.list"
ROSDEP_FILE_LOCATION = "/etc/ros/rosdep/sources.list.d/20-default.list"
GAZEBO_MODELS_REPO = "https://bitbucket.org/osrf/gazebo_models"
GAZEBO_MODELS_DIR_SUFFIX = "/gazebo_models"

# Config locations
SYSTEM_CONFIG_FILE = "/etc/bwi/bwi-update/config"
CURRENT_SYSTEM_CONFIG = "/etc/bwi/bwi-update/current"
USER_CONFIG_DIR = os.path.expanduser("~") + "/.bwi"
USER_CONFIG_FILE = USER_CONFIG_DIR + "/config"
CURRENT_USER_CONFIG = USER_CONFIG_DIR + "/current"
TMP_DIR = "/tmp/bwi_update"

# some constants defining workspace type
CATKIN = "catkin"
ROSBUILD = "rosbuild"
GENERIC = "generic"

DEFAULT_UBUNTU_DISTRO = "precise"
DEFAULT_ROS_DISTRO = "groovy"
DEFAULT_TARGET = "/opt/ros/" + DEFAULT_ROS_DISTRO

DEFAULT_BASE_DIR = os.path.expanduser("~") + "/ros"
DEFAULT_CATKIN_WS = DEFAULT_BASE_DIR + "/catkin_ws"

# should be converted to class variables when this script is improved
final_source_list = list()
print_command = False
dry_run = False

#helper functions

def printError(text):
  print "\033[31m" + text + "\033[0m"

def printSuccess(text):
  print "\033[33m" + text + "\033[0m"

def printBoldText(text):
  print "\033[1m[" + text + "]\033[0m"

def printResult(success):
  if success:
    printSuccess(" - Done");
  else:
    printError(" - Failed");

def isSuperUser():

  return os.getuid() == 0

def md5ForFile(file_name, block_size=2**20):
  # http://stackoverflow.com/questions/1131220/get-md5-hash-of-a-files-without-open-it-in-python
  f = open(file_name,"rb")
  md5 = hashlib.md5()
  while True:
    data = f.read(block_size)
    if not data:
      break
    md5.update(data)
  f.close()
  return md5.hexdigest()

def userQuery(question, default="no"):
    """Ask a yes/no question via raw_input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is one of "yes" or "no".

    from: http://stackoverflow.com/questions/3041986/python-command-line-yes-no-input
    """
    valid = {"yes":True,   "y":True,  "ye":True,
             "no":False,     "n":False}
    if default == None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        sys.stdout.write(question + prompt)
        choice = raw_input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' "\
                             "(or 'y' or 'n').\n")

def testPath(path):
  return os.path.exists(path)

def call(command, verbose=False, verbose_error=True, cwd=None):
  if print_command or dry_run:
    print " ".join(command)
  if not dry_run:
    if verbose:
      p = subprocess.Popen(command,cwd=cwd)
      p.wait()
      return p.returncode == 0
    elif verbose_error:
      p = subprocess.Popen(command, stdout=subprocess.PIPE, cwd=cwd)
      p.wait()
      return p.returncode == 0
    else:
      p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=cwd)
      p.wait()
      return p.returncode == 0
  return True

def callWsCommand(args, type=CATKIN, ws=DEFAULT_CATKIN_WS,verbose=False,verbose_error=True):
  command = "rosws"
  command_package = "python-rosinstall"
  if type == CATKIN:
    command = "wstool"
    command_package = "python-wstool"
    ws = ws + "/src"
  elif type == GENERIC:
    command = "wstool"
    command_package = "python-wstool"
  return call(["/bin/bash","-c","unset ROS_WORKSPACE && " + command + " " + " ".join(args)],cwd=ws,verbose=verbose,verbose_error=verbose_error)

def isWebAddress(file):
  return file[0:7] == "http://" or file[0:8] == "https://"

def anonymize(file):
  return file + '_' + ''.join(random.choice(string.ascii_uppercase + string.digits) for x in range(20))

def resolveFromWeb(file):
  if isWebAddress(file):
    file_name = file.split('/')[-1]
    local_file_path = TMP_DIR + "/" + anonymize(file_name)
    success = call(["wget", "--quiet", file, "-O", local_file_path])
    if not success:
      return None
    file = local_file_path
  return file

def getPackageNamesFromRosinstallDict(rosinstall_dict):
  local_names = [local_entry[local_entry.keys()[0]]['local-name'] for local_entry in rosinstall_dict]
  return local_names

def getPackageNamesFromRosinstallFile(rosinstall_file):
  rosinstall_file = resolveFromWeb(rosinstall_file)
  f = open(rosinstall_file, "r")
  rosinstall_dict = yaml.load(f)
  return getPackageNamesFromRosinstallDict(rosinstall_dict)

# primary functions

def installROSRepository(distro=DEFAULT_UBUNTU_DISTRO, remove=False):
  if not remove:
    printBoldText("Updating sources with location of ROS Repository")
    if testPath(ROS_SOURCES_LOCATION):
      print " - Existing sources file for repository found. Overwriting."
    f = open(ROS_SOURCES_LOCATION,'w')
    f.write("deb http://packages.ros.org/ros/ubuntu " + distro + " main")
    f.close()
    success = True
    printResult(success)
    return success
  else:
    printBoldText("Removing location of ROS Repository from sources")
    if not testPath(ROS_SOURCES_LOCATION):
      print " - Sources file not found."
      return True
    success = call(["rm","-rf",ROS_SOURCES_LOCATION])
    printResult(success)
    return success

def installROSKey():
  printBoldText("Installing ROS key")
  p1 = subprocess.Popen(["wget","http://packages.ros.org/ros.key","--quiet","-O","-"],stdout=subprocess.PIPE,stderr=subprocess.PIPE);
  returncode = subprocess.call(["apt-key","add","-"],stdin=p1.stdout,stdout=subprocess.PIPE)
  printResult(returncode == 0)
  return returncode == 0

def updateApt():
  printBoldText("Updating apt-get")
  success = call(["apt-get", "update"])
  printResult(success)
  return success

def installAptPackages(package_list, remove=False):
  printBoldText("Installing/Removing packages from apt-get")
  text = "Installing"
  command = "install"
  if remove:
    text = "Removing"
    command = "remove"
  all_packages_successful = True
  for package_name in package_list:
    print " - " + text + " " + package_name + "..."
    success = call(["apt-get", command, "--yes", package_name], verbose=True)
    print "  ",
    printResult(success)
    all_packages_successful = all_packages_successful and success
  return all_packages_successful

def initializeRosdep(remove=False):
  if not remove:
    printBoldText("Initializing rosdep")
    if testPath(ROSDEP_FILE_LOCATION):
      print " - Default rosdep sources file already exists. Reinitializing."
      call(["rm","-rf",ROSDEP_FILE_LOCATION])
    success = call(["rosdep","init"])
    printResult(success)
    return success
  else:
    printBoldText("Removing rosdep sources")
    if not testPath(ROSDEP_FILE_LOCATION):
      print " - Default rosdep sources file does not exist."
      return True
    else:
      success = call(["rm","-rf",ROSDEP_FILE_LOCATION])
      printResult(success)
      return success

def updateRosdep():
  printBoldText("Updating rosdep rules")
  success = call(["rosdep","update"],verbose=True)
  printResult(success)
  return success

def printFinalMessage():
  print "\nPlease ensure that the following lines have been appended to " + os.path.expanduser("~") + "/.bashrc:\n"
  for s in final_source_list:
    print s

def initializeWorkspace(remove=False,type=CATKIN,ws=DEFAULT_CATKIN_WS,target=DEFAULT_TARGET):
  if not remove:
    printBoldText("Initializing workspace of type: " + type + " in " + ws)
    if type not in [CATKIN, ROSBUILD, GENERIC]:
      print " - Unknown workspace type: " + type + ". Cannot continue."
      success = False
    else:
      if testPath(ws):
        print " - Workspace directory is not empty. Cannot continue."
        success = False
      else:
        if type == CATKIN:
          if call(["mkdir","-p", ws + "/src"]):
            if call(["/bin/bash","-c","source " + target + "/setup.bash && catkin_make"],cwd=ws):
              success = callWsCommand(["init", ws + "/src"],type,ws)
              if not success:
                if not call(["rm","-rf",ws]):
                  print " - Unable to remove stray ws directory at " + ws
            else:
              print " - Unable to initialize catkin workspace"
              success = False
          else:
            print " - Worskpace directory does not exist, and unable to create it. Cannot continue"
            success = False
        elif type == ROSBUILD:
          if call(["mkdir","-p",ws]):
            success = callWsCommand(["init",ws,target],type,ws)
            if not success: 
              if not call(["rm","-rf",ws]):
                print " - Unable to remove stray ws directory at " + ws
          else:
            print " - Worskpace directory does not exist, and unable to create it. Cannot continue"
            success = False
        else: 
          if call(["mkdir","-p", ws]):
            success = callWsCommand(["init", ws],type,ws)
            if not success:
              if not call(["rm","-rf",ws]):
                print " - Unable to remove stray ws directory at " + ws
           
  if remove or not success:
    printBoldText("Removing workspace from " + ws)
    if not testPath(ws):
      print " - Workspace does not exist in " + ws
      return True
    else:
      success = call(["rm","-rf",ws])
  printResult(success)
  return success

def rosinstallROSPackage(rosinstall_file, type=CATKIN, ws=DEFAULT_CATKIN_WS):
  printBoldText("Merging " + rosinstall_file + " in " + ws)
  if type not in [CATKIN, ROSBUILD, GENERIC]:
    print " - Unknown workspace type: " + type + ". Cannot continue."
    success = False
  else:
    success = callWsCommand(["merge","--confirm-all","--target-workspace="+ws,rosinstall_file],type,ws)
  printResult(success)
  return success

def removeROSPackage(package_name, type=CATKIN, ws=DEFAULT_CATKIN_WS):
  printBoldText("Removing " + package_name + " from " + ws)
  if type not in [CATKIN, ROSBUILD, GENERIC]:
    print " - Unknown workspace type: " + type + ". Cannot continue."
    success = False
  else:
    if callWsCommand(["rm",package_name],type,ws=ws):
      success = call(["rm","-rf",ws+"/"+package_name])
    else:
      print " - failed removing " + package_name + " from rosinstall file"
      success = False
  printResult(success)
  return success

def patchPackage(package_name, patch_file, type=CATKIN, ws=DEFAULT_CATKIN_WS):
  printBoldText("Patching " + package_name + " using " + patch_file)
  if type == CATKIN:
    ws = ws + "/src"
  package_dir = ws + "/" + package_name
  #resolve web address
  patch_file = resolveFromWeb(patch_file)
  #check if patch has already been applied
  patch_hash = md5ForFile(patch_file)
  patch_log = package_dir + "/applied_patches"
  if testPath(patch_log):
    #patch log is available - let us see if this patch has already been applied
    patched_lines = [line.rstrip('\n') for line in open(patch_log)]
    if patch_hash in patched_lines:
      print " - This patch has already been applied"
      return True
  #ok, everything seems set. Lets apply the patch
  success = call(["patch","--force","-p0","-d",package_dir,"-i",patch_file])
  if success and not dry_run:
    f = open(patch_log,"a")
    f.write(patch_hash + "\n")
    f.close
  printResult(success)
  #remove patch file
  call(["rm","-rf",patch_file])
  return success

def updateConfig(config_file_location, config=USER_CONFIG_FILE):
  printBoldText("Updating " + config + " to " + config_file_location) 
  #check if config file location is a web address
  if isWebAddress(config_file_location):
    local_config = dict()
    local_config['resolve'] = config_file_location
    directory = os.path.dirname(os.path.realpath(config))
    call(["mkdir","-p",directory])
    f = open(config,"w")
    yaml.dump(local_config, f)
    f.close()
    success = True
  else:
    success = call(["cp",config_file_location,config])
  printResult(success)
  if (success):
    return 0
  else:
    return 1

def resolveConfigWeb(config):
  if 'resolve' in config.keys():
    config_file = resolveFromWeb(config['resolve'])
    f2 = open(config_file)
    config = yaml.load(f2)
  return config

def readConfigFile(config_file=USER_CONFIG_FILE):
  f = open(config_file)
  config = yaml.load(f)
  return resolveConfigWeb(config)

def getDefaultUserConfig():
  if testPath(SYSTEM_CONFIG_FILE):
    system = readConfigFile(SYSTEM_CONFIG_FILE)
  else:
    printError("Unable to find system configuration file. Please contact your system administrator.")
    return None
  config = system['default_user']
  return resolveConfigWeb(config)

def synchronizeSystem():

  installROSRepository()
  installROSKey()

  if testPath(SYSTEM_CONFIG_FILE):
    new_system = readConfigFile(SYSTEM_CONFIG_FILE)
    new_packages = new_system['apt_packages']['managed'] + new_system['apt_packages']['unmanaged']
  else:
    printError("Unable to find system configuration file. Have you initialized using --config flag?")
    return 1
  old_packages = []
  if testPath(CURRENT_SYSTEM_CONFIG):
    # current system config exists
    # calculate differences
    old_system = readConfigFile(CURRENT_SYSTEM_CONFIG)
    old_packages = old_system['apt_packages']['managed']
  packages_to_install = new_packages # provide a flag to do changes only
  installAptPackages(packages_to_install)
  packages_to_remove = [package for package in old_packages if package not in new_packages]
  installAptPackages(packages_to_remove, remove=True)

  initializeRosdep()

  #write out the current configuration
  if not dry_run:
    f = open(CURRENT_SYSTEM_CONFIG, "w")
    yaml.dump(new_system, f) #needs to be fancier for error checking
    f.close()

  return 0

def synchronizeUserSpace():

  if testPath(USER_CONFIG_FILE):
    config = readConfigFile(USER_CONFIG_FILE)
  else:
    config = getDefaultUserConfig()

  if not config:
    return 1

  # Need to process catkin workspace first if it exists
  rosbuild_setup_target = None
  source_target = DEFAULT_TARGET
  ros_workspace_target = None
  for ws_name, ws in config['ws'].iteritems():
    if ws['type'] == CATKIN:
      base_dir = os.path.expanduser("~") + "/" + ws['dir']
      rosbuild_setup_target = base_dir + "/devel"
      source_target = base_dir + "/devel/setup.bash"
      ros_workspace_target = base_dir + "/src" 
      break

  # If rosbuild also exists, the source target needs to switch 
  for ws_name, ws in config['ws'].iteritems():
    if ws['type'] == ROSBUILD:
      base_dir = os.path.expanduser("~") + "/" + ws['dir']
      source_target = base_dir + "/setup.bash" 
      ros_workspace_target = base_dir 
      break

  stable = True

  #initialize workspaces as required
  for build_type in [CATKIN,ROSBUILD,GENERIC]: #CATKIN needs to be first if both overlays are used
    for ws_name, ws in config['ws'].iteritems():
      if ws['type'] == build_type:
        base_dir = os.path.expanduser("~") + "/" + ws['dir']
        # Initialization
        if testPath(base_dir):
          if build_type == CATKIN:
            success = testPath(base_dir + "/src/.rosinstall")
          else:
            success = testPath(base_dir + "/.rosinstall")
          if success:
            printBoldText("Found existing " + build_type + " workspace at " + base_dir + ". Skipping initialization")
          else:
            printError("For " + build_type + " workspace, directory " + base_dir + " exists, but it is not a valid workspace.")
            stable = False
        else:
          target = DEFAULT_TARGET
          if build_type == ROSBUILD and rosbuild_setup_target:
            target = rosbuild_setup_target
          success = initializeWorkspace(type=build_type,ws=base_dir,target=target)
          if not success:
            stable = False
        break

  if not stable:
    printError("This is a fatal error")
    return False

  # compute new workspace packages
  new_packages = dict()
  ws_suffix = {CATKIN: '/src', ROSBUILD: '', GENERIC: ''}
  for ws_name, ws in config['ws'].iteritems():
    build_type = ws['type']
    base_dir = os.path.expanduser("~") + "/" + ws['dir']
    new_packages[ws_name] = []
    
    # update individual entries as required
    if 'rosinstall' in ws:
      for entry in ws['rosinstall']:
        if 'uri' in entry.keys():
          rosinstall_target = entry['uri']
          new_packages[ws_name].extend(getPackageNamesFromRosinstallFile(rosinstall_target))
        else:
          rosinstall_target = TMP_DIR + anonymize("/rosinstall_target")
          tmp_file = open(rosinstall_target,"w")
          yaml.dump([entry], tmp_file)
          tmp_file.close()
          package_names = getPackageNamesFromRosinstallDict([entry]) 
          new_packages[ws_name].extend(package_names)
        rosinstallROSPackage(rosinstall_target,build_type,base_dir)
      #update workspace
      if len(new_packages[ws_name]) != 0:
        ws_loc = base_dir + ws_suffix[build_type]
        printBoldText("Updating " + str(new_packages[ws_name]) + " in " + base_dir + ". This may take a while")
        success = callWsCommand(["update","--target-workspace="+ws_loc]+new_packages[ws_name],type=build_type,ws=base_dir,verbose=True)
        printResult(success)

    # apply patches as required
    if 'patches' in ws:
      for patch in ws['patches']:
        package_name = patch.keys()[0]
        patch_uri = patch[package_name]
        patchPackage(package_name,patch_uri,build_type,base_dir)

    # export bash as required
    if 'bash' in ws:
      text = ws['bash']
      file_name = USER_CONFIG_DIR + "/" + ws_name + ".bash"
      f = open(file_name,'w')
      f.write(text)
      f.close()
      final_source_list.append("source " + file_name)

  # compute differences with old config and remove unneeded packages
  if testPath(CURRENT_USER_CONFIG):
    old_config = readConfigFile(CURRENT_USER_CONFIG)

    # remove redundant packages
    old_packages = dict()
    for ws_name, ws in config['ws'].iteritems():
      build_type = ws['type']
      base_dir = os.path.expanduser("~") + "/" + ws['dir']
      old_packages[ws_name] = []
      if ws_name in old_config['ws']:
        ws = old_config['ws'][ws_name]
        if 'rosinstall' in ws:
          for entry in ws['rosinstall']:
            if 'uri' in entry.keys():
              old_packages[ws_name].extend(getPackageNamesFromRosinstallFile(entry['uri']))
            else:
              package_names = getPackageNamesFromRosinstallDict([entry]) 
              old_packages[ws_name].extend(package_names)
      packages_to_remove = [package for package in old_packages[ws_name] if package not in new_packages[ws_name]]
      for package in packages_to_remove:
        remove_package = userQuery("The following package: " + package + " is no longer required in " + ws_name + "(" + build_type + " - " + base_dir + "). Remove? (WARN: Any local changes to this package will be lost)")
        if remove_package:
          removeROSPackage(package, build_type, base_dir)

    # remove redundant workspaces
    workspaces_to_remove = [ws_name for ws_name in old_config['ws'].keys() if ws_name not in config['ws'].keys()]
    for ws_name in workspaces_to_remove:
      ws = old_config['ws'][ws_name]
      build_type = ws['type']
      base_dir = os.path.expanduser("~") + "/" + ws['dir']
      remove_workspace = userQuery("The following workspace: " + ws_name + "(" + build_type + " - " + base_dir + ") is no longer required. Remove? (WARN: Any local changes in this workspace will be lost)")
      if remove_workspace:
        initializeWorkspace(remove=True,type=build_type,ws=base_dir)

  # setup bash
  file_name = USER_CONFIG_DIR + "/workspace.bash"
  f = open(file_name,'w')
  f.write("source " + source_target + "\n")
  if ros_workspace_target:
    f.write("export ROS_WORKSPACE=" + ros_workspace_target + "\n")
  f.close()
  final_source_list.append("source " + file_name)

  # update rosdep rules
  updateRosdep()

  printFinalMessage()

  # copy over current config
  if not dry_run:
    f = open(CURRENT_USER_CONFIG, "w")
    yaml.dump(config, f) #needs to be fancier for error checking
    f.close()

  return 0

if  __name__ =='__main__':
  parser = argparse.ArgumentParser()
  parser.add_argument("-s","--sync", action="store_true", help="synchronize user or system (if used with --system) setup")
  parser.add_argument("-S","--system", action="store_true", help="runs system setup (requires sudo access)")
  parser.add_argument("-p","--print-command", action="store_true", help="displays bash commands and executes them")
  parser.add_argument("-d","--dry-run", action="store_true", help="displays bash commands, but does not execute them")
  parser.add_argument("-c","--config", type=str, help="set config file for user or system (if used with --system). Can take an absolute file path or url.")
  args = parser.parse_args()

  dry_run = args.dry_run
  print_command = args.print_command

  if (isSuperUser() and not args.system) or (not isSuperUser() and args.system):
    print ""
    printError("Illegal usage. You should run the command as either:")
    print " sudo bwi-update --system <additional_args>     (for system updates)"
    print " bwi-update <additional_args>                   (for user update)"
    print ""
    parser.print_help()
    sys.exit(1)

  call(["mkdir", "-p", TMP_DIR])
  call(["chmod", "a+rwx", TMP_DIR])

  if args.config:
    if args.system:
      error_code = updateConfig(args.config,SYSTEM_CONFIG_FILE)
    else:
      if not call(["mkdir", "-p", USER_CONFIG_DIR]):
        printError("Unable to construct local config directory: " + USER_CONFIG_DIR + ". Cannot continue.")
        error_code = 1
      else:
        error_code = updateConfig(args.config,USER_CONFIG_FILE)

  elif args.sync:
    if args.system:
      error_code = synchronizeSystem()
    else:
      if not call(["mkdir", "-p", USER_CONFIG_DIR]):
        printError("Unable to construct local config directory: " + USER_CONFIG_DIR + ". Cannot continue.")
        error_code = 1
      else:
        error_code = synchronizeUserSpace()

  else:
    printError("\nYou need to provide either --sync or --config CONFIG to use this tool\n")
    parser.print_help()
    error_code = 1

  call(["rm", "-rf", TMP_DIR])
  sys.exit(error_code)
